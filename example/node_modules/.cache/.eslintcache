[{"C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\stories\\pie-story\\Pie.stories.tsx":"1","C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\components\\pie\\Pie.tsx":"2","C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\utils\\mathUtils.ts":"3","C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\components\\Canvas.tsx":"4","C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\utils\\promiseUtil.ts":"5","C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\utils\\canvasUtils.ts":"6","C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\hooks\\useMouse.ts":"7","C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\utils\\mouseUtils.ts":"8"},{"size":1154,"mtime":1694737569719,"results":"9","hashOfConfig":"10"},{"size":9518,"mtime":1694738438303,"results":"11","hashOfConfig":"10"},{"size":296,"mtime":1694723212914,"results":"12","hashOfConfig":"10"},{"size":659,"mtime":1694380519353,"results":"13","hashOfConfig":"10"},{"size":337,"mtime":1694731082869,"results":"14","hashOfConfig":"10"},{"size":457,"mtime":1694553497455,"results":"15","hashOfConfig":"10"},{"size":1870,"mtime":1694737389970,"results":"16","hashOfConfig":"10"},{"size":662,"mtime":1694553039146,"results":"17","hashOfConfig":"10"},{"filePath":"18","messages":"19","suppressedMessages":"20","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"nl55a",{"filePath":"21","messages":"22","suppressedMessages":"23","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24"},{"filePath":"25","messages":"26","suppressedMessages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"28","messages":"29","suppressedMessages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","suppressedMessages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40"},{"filePath":"41","messages":"42","suppressedMessages":"43","errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"44"},"C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\stories\\pie-story\\Pie.stories.tsx",[],[],"C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\components\\pie\\Pie.tsx",["45","46","47","48"],[],"import React, { MutableRefObject, useCallback, useEffect, useLayoutEffect, useRef, useState } from 'react'\r\nimport Canvas from '../Canvas'\r\nimport { sigmoid, sumOfArray } from '../../utils/mathUtils';\r\nimport styles from './pie.module.css'\r\nimport { Position } from '../../utils/mouseUtils';\r\nimport { sleep } from '../../utils/promiseUtil';\r\nimport { clearCanvas } from '../../utils/canvasUtils';\r\nimport useMouse from '../../hooks/useMouse';\r\nimport { ItemProps, PathData, PieProps } from '../../interfaces/pie-interfaces';\r\n\r\n\r\n\r\n/**\r\n * @description It creates piece\r\n * @param ctx \r\n * @param cx \r\n * @param cy \r\n * @param radius \r\n * @param startAngle \r\n * @param endAngle \r\n * @param fillcolor \r\n * @param scaled \r\n * @returns void\r\n */\r\nasync function fillWedge(ctx: CanvasRenderingContext2D, cx: number, cy: number, radius: number, startAngle: number,\r\n  endAngle: number,\r\n  fillcolor: string,\r\n  scaled: boolean,\r\n  over: boolean,\r\n  scale: number,\r\n  initialLoadingRef: any): Promise<Path2D> {\r\n  let path = new Path2D();\r\n\r\n\r\n  if (!initialLoadingRef.current) {\r\n    for (let i = startAngle; i <= endAngle; i = i + 0.20) {\r\n      await sleep(10);\r\n      path = new Path2D();\r\n      ctx.save();\r\n      path.moveTo(cx, cy);\r\n      const p=new Path2D();\r\n      let transform=new DOMMatrix();\r\n      if (scaled) {\r\n        transform=transform.translate(cx,cy)\r\n        .scale(scale).translate(-cx,-cy)\r\n      }\r\n\r\n      if (over) {\r\n        ctx.shadowColor = fillcolor;\r\n        ctx.shadowBlur = radius / 4;\r\n      }\r\n     \r\n      path.arc(cx, cy, radius, i, i + 0.20 > endAngle ? endAngle : i + 0.20);\r\n      path.closePath();\r\n      ctx.fillStyle = fillcolor;\r\n      p.addPath(path,transform);\r\n      ctx.fill(p);\r\n      ctx.restore();\r\n    }\r\n  }\r\n\r\n  path = new Path2D();\r\n  ctx.save();\r\n  path.moveTo(cx, cy);\r\n  ctx.shadowColor = fillcolor;\r\n  ctx.shadowBlur = radius / 10;\r\n  const p=new Path2D();\r\n  let transform=new DOMMatrix();\r\n  if (scaled) {\r\n    transform=transform.translate(cx,cy)\r\n    .scale(scale).translate(-cx,-cy)\r\n  }\r\n\r\n  path.arc(cx, cy, radius, startAngle, endAngle);\r\n  path.closePath();\r\n  ctx.fillStyle = fillcolor;\r\n\r\n  if (over) {\r\n    ctx.shadowColor = fillcolor;\r\n    ctx.shadowBlur = radius / 4;\r\n  }\r\n  p.addPath(path,transform);\r\n  ctx.fill(p);\r\n  ctx.restore();\r\n\r\n  return p;\r\n}\r\n\r\n\r\n\r\n/**\r\n * radius @default 120\r\n * scaled @default false\r\n * data  It is array for data\r\n */\r\nconst Pie = ({ radius = 120, data,textToCenter=true, scaled = false, onMouseClickPiece = (item) => {\r\n  alert(item.name)\r\n} }: PieProps) => {\r\n  const canvasRef: MutableRefObject<any> = useRef();\r\n  const pathsRef: MutableRefObject<PathData[] | undefined> = useRef(undefined);\r\n  const [dataCopy, setDataCopy] = useState(data);\r\n  const initialLoadingRef = useRef(false);\r\n  const settingsRef:MutableRefObject<{\r\n    radius:number,textToCenter:boolean,scaled:boolean,data:ItemProps[]\r\n  }>=useRef({ radius,textToCenter,scaled,data});\r\n\r\n\r\n  \r\n\r\n  const mouseMove = useCallback(async (_: MouseEvent,position:Position,ctx:CanvasRenderingContext2D) => {\r\n\r\n    if (pathsRef.current) {\r\n      for (let i = 0; i < pathsRef.current.length; ++i) {\r\n        const item = pathsRef.current[i];\r\n        if (ctx.isPointInPath(item.path, position.x, position.y)) {\r\n          if (!item.over) {\r\n            item.over = true;\r\n            await renderData(item);\r\n            canvasRef.current.style.cursor=\"pointer\";\r\n            break;\r\n          }\r\n        } else {\r\n          if (item.over === true) {\r\n            item.over = false;\r\n            await renderData(null);\r\n            canvasRef.current.style.cursor=\"default\";\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  },[])\r\n\r\n  const mouseClick = useCallback((_: MouseEvent,position:Position,ctx:CanvasRenderingContext2D) => {\r\n    pathsRef.current?.forEach(item => {\r\n      if (ctx.isPointInPath(item.path, position.x, position.y)) {\r\n        if (onMouseClickPiece)\r\n          onMouseClickPiece(item.data);\r\n      }\r\n    })\r\n  },[])\r\n\r\n  // This prevents to stay over true when the mouse leave out of canvas\r\n  const mouseLeave = useCallback(() => {\r\n    if (!pathsRef.current?.every(item => {\r\n      const beforeOverValue = item.over;\r\n      item.over = false;\r\n      return !beforeOverValue;\r\n    }))\r\n      renderData(null);\r\n  },[])\r\n\r\n  useMouse(\r\n    canvasRef,\r\n    !!onMouseClickPiece,\r\n    [],\r\n    mouseMove,\r\n    mouseClick,\r\n    mouseLeave);\r\n\r\n\r\n\r\n  const renderData = useCallback(async (item: PathData | null | undefined) => {\r\n\r\n    // get context\r\n    const ctx = canvasRef.current.getContext(\"2d\") as CanvasRenderingContext2D;\r\n    const canvas = canvasRef.current as HTMLCanvasElement;\r\n    if (ctx) {\r\n      // Initially, clear the whole screen\r\n      clearCanvas(ctx);\r\n\r\n      // sum all value\r\n      const totalValue = sumOfArray(settingsRef.current.data.map(item => item.value));\r\n\r\n      // calculate angel according to 360 value\r\n      const withPercent = settingsRef.current.data.map(item => ({\r\n        root: item,\r\n        name: item.name,\r\n        angle: (360 * item.value) / totalValue,\r\n        bgColor: item.backgroundColor,\r\n        textColor:item.textColor\r\n      }))\r\n      let prev = 0;\r\n\r\n      const paths: PathData[] = []\r\n\r\n      /*\r\n        For every single pie piece, combine all peice with its calculated angle for PI number\r\n      */\r\n      for (let i = 0; i < withPercent.length; i++) {\r\n        const first = withPercent[i];\r\n        const endAngle = ((first.angle) * (Math.PI / 180)) + prev;\r\n\r\n        const over = item?.data?.name === first.name ? item.over : false;\r\n\r\n        const differenceWithStartEndAngle=sigmoid(endAngle-prev);\r\n        // Draw and push for mouse event\r\n        paths.push({\r\n          path: await fillWedge(ctx, canvas.width / 2, canvas.height / 2, settingsRef.current.radius, prev, endAngle, first.bgColor, settingsRef.current.scaled, over,differenceWithStartEndAngle, initialLoadingRef),\r\n          data: first,\r\n          over,\r\n          startAngle: prev,\r\n          endAngle,\r\n          scale:differenceWithStartEndAngle\r\n        });\r\n\r\n\r\n        prev += (first.angle) * (Math.PI / 180);\r\n      }\r\n      if (!initialLoadingRef.current)\r\n       initialLoadingRef.current = true;\r\n      \r\n      pathsRef.current = paths;\r\n      for (let i = 0; i < withPercent.length; i++) {\r\n  \r\n        const first = withPercent[i];\r\n        const scaleValue=settingsRef.current.scaled?sigmoid(((first.angle) * (Math.PI / 180))):1;\r\n        ctx.save();\r\n\r\n        let textX = Math.round(((canvas.width / 2) + (settingsRef.current.radius / 1.75)*scaleValue));\r\n        let textY = (canvas.height / 2);\r\n\r\n        const angle = prev + (first.angle * (Math.PI / 180)) / 2;\r\n        textX = textX - (canvas.width / 2) * 1\r\n        textY = textY - (canvas.height / 2) * 1\r\n        const a = Math.cos(-angle) * textX + Math.sin(-angle) * textY;\r\n        const b = -Math.sin(-angle) * textX + Math.cos(-angle) * textY;\r\n        const percent: number = (100 * (first.angle / 360));\r\n        const fontSize = ((settingsRef.current.radius / 10) * Math.round((100 / (100 - Math.round(percent)))))*scaleValue;\r\n\r\n        const posX=(canvas.width / 2) + a;\r\n        const posY=(canvas.height / 2) + b;\r\n        ctx.font = (fontSize >= 30 ? 30 : fontSize) + \"px Sans-serif\";\r\n        ctx.textBaseline = \"middle\"\r\n        ctx.textAlign = \"center\"\r\n    \r\n        if(settingsRef.current.textToCenter){\r\n          const withoutPIAngle=angle*(180/Math.PI);\r\n          const remindDivided360=withoutPIAngle%360;\r\n          const xYAngle=remindDivided360>=0 && remindDivided360 <=90 ||\r\n          remindDivided360>=270 && remindDivided360 <=360?0:180;\r\n          ctx.setTransform(new DOMMatrix()\r\n          .translate(posX,posY)\r\n          .rotate(xYAngle,xYAngle,remindDivided360)\r\n          .translate(-posX,-posY))\r\n         \r\n        }\r\n      \r\n        ctx.fillStyle = first.textColor||\"white\";\r\n\r\n        ctx.fillText(percent.toFixed(2) + \"%\", posX,posY);\r\n\r\n        ctx.restore();\r\n        prev += first.angle * (Math.PI / 180);\r\n      }\r\n    }\r\n  }, [radius, dataCopy,textToCenter,scaled])\r\n\r\n  /*\r\n  If the data changes, run this\r\n  */\r\n  useLayoutEffect(() => {\r\n    pathsRef.current = undefined;\r\n    setDataCopy(data);\r\n  }, [data])\r\n\r\n  useEffect(()=>{\r\n    settingsRef.current={\r\n      radius,textToCenter,scaled,data\r\n    }\r\n  },[radius,textToCenter,scaled,data])\r\n\r\n  /*\r\n   If radius and updateCanvasSizeWhenScaled change, run this\r\n  */\r\n  useEffect(() => {\r\n    if (canvasRef.current) {\r\n      canvasRef.current.width = radius * 2.5;\r\n      canvasRef.current.height = radius * 2.5;\r\n    }\r\n  }, [radius])\r\n\r\n  useEffect(() => {\r\n    renderData(null);\r\n  }, [renderData])\r\n\r\n  return (\r\n    <div className={[styles.wrapper].join(\" \")}>\r\n      <Canvas style={{\r\n        minWidth: radius * 2,\r\n        minHeight: radius * 2,\r\n      }} ref={canvasRef}>\r\n      </Canvas>\r\n      <div>\r\n        <ul className={\r\n          styles.ul\r\n        }>\r\n          {\r\n            dataCopy.map(item => <li className={styles.li} key={item.name}>\r\n              <div style={{\r\n                width: \"10px\",\r\n                height: \"10px\",\r\n                backgroundColor: item.backgroundColor\r\n              }}></div>\r\n              <span title={item.name} className={styles.name}>\r\n                {\r\n                  item.name\r\n                }\r\n              </span>\r\n            </li>)\r\n          }\r\n        </ul>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default React.memo(Pie)","C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\utils\\mathUtils.ts",[],[],"C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\components\\Canvas.tsx",[],[],"C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\utils\\promiseUtil.ts",[],[],"C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\utils\\canvasUtils.ts",[],[],"C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\hooks\\useMouse.ts",["49","50","51","52"],[],"import { MutableRefObject, useEffect } from 'react'\r\nimport { D } from '../utils/mouseUtils';\r\nimport { extractContextAndCanvasFromRef } from '../utils/canvasUtils';\r\n\r\nconst useMouse = (canvasRef: MutableRefObject<HTMLCanvasElement>, hasMouseClick: boolean,extraDependency:any[], onMouseMove: Function, onMouseClick: Function, onMouseLeave: Function) => {\r\n\r\n    \r\n    // Mouse leave\r\n    useEffect(() => {\r\n        const {canvas,ctx}=extractContextAndCanvasFromRef(canvasRef);\r\n        const mouseLeave = (e: MouseEvent) => {\r\n            onMouseLeave(e,ctx);\r\n        }\r\n        canvas.addEventListener(\"mouseleave\", mouseLeave);\r\n\r\n        return () => {\r\n            canvas.removeEventListener(\"mouseleave\", mouseLeave);\r\n        }\r\n    }, [...extraDependency])\r\n\r\n    /*\r\n       I used this for mouse events\r\n    */\r\n    useEffect(() => {\r\n        const {canvas,ctx}=extractContextAndCanvasFromRef(canvasRef);\r\n        const mouseMove = async (e: MouseEvent) => {\r\n            const positionMouse = D(canvas, e);\r\n            onMouseMove(e, positionMouse,ctx);\r\n        }\r\n\r\n        const mouseClick = (e: MouseEvent) => {\r\n            const positionMouse = D(canvas, e);\r\n            onMouseClick(e, positionMouse,ctx);\r\n        }\r\n\r\n        // This prevents to stay over true when the mouse leave out of canvas\r\n\r\n        canvas.removeEventListener(\"mousemove\", mouseMove);\r\n        canvas.addEventListener(\"mousemove\", mouseMove);\r\n\r\n        if (hasMouseClick) {\r\n            canvas.removeEventListener(\"click\", mouseClick);\r\n            canvas.addEventListener(\"click\", mouseClick);\r\n        }\r\n\r\n        return () => {\r\n            canvas.removeEventListener(\"mousemove\", mouseMove);\r\n            canvas.removeEventListener(\"click\", mouseClick);\r\n        }\r\n    }, [hasMouseClick,...extraDependency])\r\n    return (\r\n      []\r\n  )\r\n}\r\n\r\nexport default useMouse","C:\\Users\\Gökhan ERGEN\\Desktop\\Files\\graphjs-core\\example\\src\\utils\\mouseUtils.ts",["53"],[],"\r\nexport interface Position{\r\n  x:number,y:number\r\n}\r\n/**\r\n * @description you can calculate mouse canvas position for its events\r\n * @param canvas \r\n * @param mouse \r\n * @returns \r\n */\r\nexport function D(canvas:HTMLCanvasElement, mouse:any):Position {\r\n    var n = canvas.getBoundingClientRect();\r\n    const scaleX = canvas.width / n.width;\r\n    const scaleY = canvas.height / n.height;\r\n    const clientX = mouse.clientX ? mouse.clientX : mouse?.touches?.item(0)?.clientX;\r\n    const clientY = mouse.clientY ? mouse.clientY : mouse?.touches?.item(0)?.clientY;\r\n    return {\r\n      x: (clientX - n.left) * scaleX,\r\n      y: (clientY - n.top) * scaleY\r\n    };\r\n}",{"ruleId":"54","severity":1,"message":"55","line":132,"column":5,"nodeType":"56","endLine":132,"endColumn":7,"suggestions":"57"},{"ruleId":"54","severity":1,"message":"58","line":141,"column":5,"nodeType":"56","endLine":141,"endColumn":7,"suggestions":"59"},{"ruleId":"54","severity":1,"message":"55","line":151,"column":5,"nodeType":"56","endLine":151,"endColumn":7,"suggestions":"60"},{"ruleId":"54","severity":1,"message":"61","line":257,"column":6,"nodeType":"56","endLine":257,"endColumn":44,"suggestions":"62"},{"ruleId":"54","severity":1,"message":"63","line":19,"column":8,"nodeType":"56","endLine":19,"endColumn":28,"suggestions":"64"},{"ruleId":"54","severity":1,"message":"65","line":19,"column":9,"nodeType":"66","endLine":19,"endColumn":27},{"ruleId":"54","severity":1,"message":"67","line":50,"column":8,"nodeType":"56","endLine":50,"endColumn":42,"suggestions":"68"},{"ruleId":"54","severity":1,"message":"65","line":50,"column":23,"nodeType":"66","endLine":50,"endColumn":41},{"ruleId":"69","severity":2,"message":"70","line":12,"column":5,"nodeType":"71","messageId":"72","endLine":12,"endColumn":44,"fix":"73"},"react-hooks/exhaustive-deps","React Hook useCallback has a missing dependency: 'renderData'. Either include it or remove the dependency array.","ArrayExpression",["74"],"React Hook useCallback has a missing dependency: 'onMouseClickPiece'. Either include it or remove the dependency array. If 'onMouseClickPiece' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["75"],["76"],"React Hook useCallback has unnecessary dependencies: 'dataCopy', 'radius', 'scaled', and 'textToCenter'. Either exclude them or remove the dependency array.",["77"],"React Hook useEffect has missing dependencies: 'canvasRef' and 'onMouseLeave'. Either include them or remove the dependency array. If 'onMouseLeave' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["78"],"React Hook useEffect has a spread element in its dependency array. This means we can't statically verify whether you've passed the correct dependencies.","SpreadElement","React Hook useEffect has missing dependencies: 'canvasRef', 'onMouseClick', and 'onMouseMove'. Either include them or remove the dependency array. If 'onMouseMove' changes too often, find the parent component that defines it and wrap that definition in useCallback.",["79"],"no-var","Unexpected var, use let or const instead.","VariableDeclaration","unexpectedVar",{"range":"80","text":"81"},{"desc":"82","fix":"83"},{"desc":"84","fix":"85"},{"desc":"82","fix":"86"},{"desc":"87","fix":"88"},{"desc":"89","fix":"90"},{"desc":"91","fix":"92"},[258,261],"let","Update the dependencies array to be: [renderData]",{"range":"93","text":"94"},"Update the dependencies array to be: [onMouseClickPiece]",{"range":"95","text":"96"},{"range":"97","text":"94"},"Update the dependencies array to be: []",{"range":"98","text":"99"},"Update the dependencies array to be: [canvasRef, onMouseLeave]",{"range":"100","text":"101"},"Update the dependencies array to be: [canvasRef, hasMouseClick, onMouseClick, onMouseMove]",{"range":"102","text":"103"},[3706,3708],"[renderData]",[4017,4019],"[onMouseClickPiece]",[4321,4323],[8087,8125],"[]",[745,765],"[canvasRef, onMouseLeave]",[1776,1810],"[canvasRef, hasMouseClick, onMouseClick, onMouseMove]"]